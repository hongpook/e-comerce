{"version":3,"sources":["../src/index.ts","../src/attrs.ts","../src/constants.ts","../src/is.ts","../src/contains.ts","../src/env.ts","../src/event.ts","../src/query.ts","../src/sanitize.ts","../src/get-by-text.ts","../src/get-by-typeahead.ts","../src/get-parent-node.ts","../src/get-scroll-position.ts","../src/is-editable-element.ts","../src/is-hidden-element.ts","../src/is-overflow-element.ts","../src/overflow.ts","../src/platform.ts","../src/raf.ts","../src/scope.ts","../src/scroll-into-view.ts"],"sourcesContent":["export * from \"./attrs\"\nexport * from \"./constants\"\nexport * from \"./contains\"\nexport * from \"./env\"\nexport * from \"./event\"\nexport * from \"./get-by-text\"\nexport * from \"./get-by-typeahead\"\nexport * from \"./get-parent-node\"\nexport * from \"./get-scroll-position\"\nexport * from \"./is\"\nexport * from \"./is-editable-element\"\nexport * from \"./is-hidden-element\"\nexport * from \"./is-overflow-element\"\nexport * from \"./overflow\"\nexport * from \"./platform\"\nexport * from \"./query\"\nexport * from \"./raf\"\nexport * from \"./scope\"\nexport * from \"./scroll-into-view\"\n","type Booleanish = boolean | \"true\" | \"false\"\n\nexport const dataAttr = (guard: boolean | undefined) => {\n  return (guard ? \"\" : undefined) as Booleanish\n}\n\nexport const ariaAttr = (guard: boolean | undefined) => {\n  return guard ? \"true\" : undefined\n}\n","export const MAX_Z_INDEX = 2147483647\n","export const isHTMLElement = (v: any): v is HTMLElement =>\n  typeof v === \"object\" && v?.nodeType === Node.ELEMENT_NODE && typeof v?.nodeName === \"string\"\n\nexport const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport const getNodeName = (node: Node | Window): string => {\n  if (isHTMLElement(node)) return node.localName || \"\"\n  return \"#document\"\n}\n\nexport function isRootElement(node: Node): boolean {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node))\n}\n\nexport const isNode = (el: any): el is Node => el.nodeType !== undefined\n\nexport const isShadowRoot = (el: any): el is ShadowRoot =>\n  el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in el\n","import { isHTMLElement } from \"./is\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n","import { isHTMLElement, isDocument, isShadowRoot } from \"./is\"\n\nexport function getDocument(el: Element | Node | Document | null) {\n  if (isDocument(el)) return el\n  return el?.ownerDocument ?? document\n}\n\nexport function getDocumentElement(el: Element | Node | Document | null): HTMLElement {\n  return getDocument(el).documentElement\n}\n\nexport function getWindow(el: Node | ShadowRoot | Document | undefined) {\n  if (isShadowRoot(el)) return getWindow(el.host)\n  if (isDocument(el)) return el.defaultView ?? window\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window\n  return window\n}\n\nexport function getActiveElement(el: HTMLElement): HTMLElement | null {\n  const doc = getDocument(el)\n  let activeElement = doc.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n\nconst styleCache = new WeakMap<HTMLElement, any>()\n\nexport function getComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n","import { contains } from \"./contains\"\n\nexport function getBeforeInputValue(event: Pick<InputEvent, \"currentTarget\">) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget as HTMLInputElement\n  return value.slice(0, selectionStart!) + (event as any).data + value.slice(selectionEnd!)\n}\n\nexport function getEventTarget<T extends EventTarget>(event: Event): T | null {\n  return (event.composedPath?.()[0] ?? event.target) as T | null\n}\n\nexport const isSelfEvent = (event: Pick<UIEvent, \"currentTarget\" | \"target\">) =>\n  contains(event.currentTarget, event.target)\n","type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends HTMLElement = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector) ?? null\n}\n\nexport type ItemToId<T> = (v: T) => string\n\nexport const defaultItemToId = <T extends HTMLElement>(v: T) => v.id\n\nexport function itemById<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  const item = itemById(v, id, itemToId)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n","export const sanitize = (str: string) =>\n  str\n    .split(\"\")\n    .map((char) => {\n      const code = char.charCodeAt(0)\n\n      if (code > 0 && code < 128) {\n        return char\n      }\n\n      if (code >= 128 && code <= 255) {\n        return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\")\n      }\n\n      return \"\"\n    })\n    .join(\"\")\n    .trim()\n","import { defaultItemToId, indexOfId, type ItemToId } from \"./query\"\nimport { sanitize } from \"./sanitize\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\")\n\nconst match = (valueText: string, query: string) => valueText.trim().toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(\n  v: T[],\n  text: string,\n  currentId?: string | null,\n  itemToId: ItemToId<T> = defaultItemToId,\n) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n","import { getByText } from \"./get-by-text\"\nimport type { ItemToId } from \"./query\"\n\nexport interface TypeaheadState {\n  keysSoFar: string\n  timer: number\n}\n\nexport interface TypeaheadOptions {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n  itemToId?: ItemToId<HTMLElement>\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350, itemToId } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId, itemToId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n","import { getDocumentElement } from \"./env\"\nimport { getNodeName, isShadowRoot } from \"./is\"\n\nexport function getParentNode(node: Node): Node {\n  if (getNodeName(node) === \"html\") {\n    return node\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as any).assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) ||\n    // Fallback.\n    getDocumentElement(node)\n\n  return isShadowRoot(result) ? result.host : result\n}\n","import { isHTMLElement } from \"./is\"\n\nexport interface ScrollPosition {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function getScrollPosition(element: HTMLElement | Window): ScrollPosition {\n  if (isHTMLElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop,\n    }\n  }\n\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY,\n  }\n}\n","import { getWindow } from \"./env\"\nimport { isHTMLElement } from \"./is\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = getWindow(el)\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n","export function isHiddenElement(node: HTMLElement) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true\n  return node.hidden\n}\n","import { getWindow } from \"./env\"\n\nconst OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/\n\nexport function isOverflowElement(el: HTMLElement): boolean {\n  const win = getWindow(el)\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el)\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display)\n}\n","import { getDocument, getWindow } from \"./env\"\nimport { getParentNode } from \"./get-parent-node\"\nimport { isHTMLElement, isRootElement } from \"./is\"\nimport { isOverflowElement } from \"./is-overflow-element\"\n\ntype OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getNearestOverflowAncestor(el: Node): HTMLElement {\n  const parentNode = getParentNode(el)\n\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode\n  }\n\n  return getNearestOverflowAncestor(parentNode)\n}\n\nexport function getOverflowAncestors(el: HTMLElement, list: OverflowAncestor = []): OverflowAncestor {\n  const scrollableAncestor = getNearestOverflowAncestor(el)\n  const isBody = scrollableAncestor === el.ownerDocument.body\n  const win = getWindow(scrollableAncestor)\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []))\n}\n","export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice()\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => pt(/iP(hone|ad|od)|iOS/)\n","export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n","import { getDocument } from \"./env\"\n\nexport interface ScopeContext {\n  getRootNode?(): Document | ShadowRoot | Node\n}\n\nexport function createScope<T>(methods: T) {\n  const screen = {\n    getRootNode: (ctx: ScopeContext) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: ScopeContext) => getDocument(screen.getRootNode(ctx)),\n    getWin: (ctx: ScopeContext) => screen.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: ScopeContext) => screen.getDoc(ctx).activeElement as HTMLElement | null,\n    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => elem === screen.getActiveElement(ctx),\n    getById: <T extends HTMLElement = HTMLElement>(ctx: ScopeContext, id: string) =>\n      screen.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      const valueAsString = value.toString()\n      if (elem.value === valueAsString) return\n      elem.value = value.toString()\n    },\n  }\n\n  return { ...screen, ...methods }\n}\n","import { isOverflowElement } from \"./is-overflow-element\"\n\nexport interface ScrollOptions extends ScrollIntoViewOptions {\n  rootEl: HTMLElement | null\n}\n\nfunction isScrollable(el: HTMLElement): boolean {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth\n}\n\nexport function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void {\n  const { rootEl, ...scrollOptions } = options || {}\n\n  if (!el || !rootEl) {\n    return\n  }\n\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return\n  }\n\n  el.scrollIntoView(scrollOptions)\n}\n"],"mappings":"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","names":["el","query","query","raf","fn"]}