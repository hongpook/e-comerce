import * as React$1 from 'react';
import React__default from 'react';
import * as _chakra_ui_react from '@chakra-ui/react';
import { HTMLChakraProps, SystemStyleObject, As, SystemProps, ThemingProps, IconProps, TextProps, ButtonGroupProps, ChakraProviderProps, ComponentWithAs, CloseButtonProps, LinkProps, ThemeTypings, SpinnerProps, MenuProps, MenuListProps, AvatarProps, ListProps, IconButtonProps, ChakraProps as ChakraProps$1, StackProps, TooltipProps, UseDisclosureReturn, ResponsiveValue, InputProps, UseToastOptions, ToastId, AlertProps, ToastPosition, CreateStandAloneToastParam, StepperProps } from '@chakra-ui/react';
export { LinkProps } from '@chakra-ui/react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { Dict, AnyPointerEvent } from '@chakra-ui/utils';
import * as _chakra_ui_system from '@chakra-ui/system';
import { ChakraProps } from '@chakra-ui/system';
import * as framer_motion from 'framer-motion';
import { HTMLMotionProps } from 'framer-motion';
import * as _chakra_ui_react_utils from '@chakra-ui/react-utils';
import { PropGetter, PropGetterV2, MaybeRenderProp } from '@chakra-ui/react-utils';
import * as _chakra_ui_toast_dist_toast_types_24f022fd from '@chakra-ui/toast/dist/toast.types-24f022fd';
import * as _chakra_ui_styled_system from '@chakra-ui/styled-system';
export { CalendarIcon, CheckIcon, ChevronDownIcon, ChevronLeftIcon, ChevronRightIcon, ChevronUpIcon, CloseIcon, FilterIcon, HamburgerIcon, MinusIcon, PlusIcon, SearchIcon, ViewIcon, ViewOffIcon } from './icons/index.mjs';
import { IconProps as IconProps$1 } from '@chakra-ui/icon';
export { s as splitProps } from './split-props-D6Izg7QS.mjs';

/**
 * Command
 * A command is used to show which key or combination of keys performs a given action.
 *
 * All single letters A-Z are uppercase.
 * For non-letter keys such as enter, esc and shift, stick to lowercase.
 * Use symbols (⌥ ⇧ ⌃ ⌘) as opposed to spelling things out.
 */
declare const Command: React$1.FC<HTMLChakraProps<'span'>>;

declare const Br: React$1.FC<HTMLChakraProps<'span'>>;

declare const useEmptyStateStyles: () => Record<string, SystemStyleObject>;
interface EmptyStateProps extends Omit<EmptyStateContainerProps, 'title'> {
    title?: React$1.ReactNode;
    description?: React$1.ReactNode;
    icon?: As;
    actions?: React$1.ReactNode;
    footer?: React$1.ReactNode;
    children?: React$1.ReactNode;
    spacing?: SystemProps['margin'];
}
/**
 * Display actionable feedback when no data is available.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/empty-state
 */
declare const EmptyState: React$1.FC<EmptyStateProps>;
interface EmptyStateContainerProps extends HTMLChakraProps<'div'>, ThemingProps<'SuiEmptyState'> {
    children?: React$1.ReactNode;
    spacing?: SystemProps['margin'];
}
declare const EmptyStateContainer: React$1.FC<EmptyStateContainerProps>;
declare const EmptyStateIcon: _chakra_ui_react.ComponentWithAs<_chakra_ui_react.ComponentWithAs<"svg", IconProps>, IconProps>;
interface EmptyStateTitleProps extends HTMLChakraProps<'h3'> {
}
declare const EmptyStateTitle: React$1.FC<EmptyStateTitleProps>;
declare const EmptyStateDescription: React$1.FC<TextProps>;
interface EmptyStateBodyProps extends HTMLChakraProps<'div'> {
    spacing?: SystemProps['margin'];
}
declare const EmptyStateBody: React$1.FC<EmptyStateBodyProps>;
declare const EmptyStateActions: React$1.FC<ButtonGroupProps>;
declare const EmptyStateFooter: React$1.FC<HTMLChakraProps<'footer'>>;

interface SaasContextValue {
    linkComponent?: React$1.ElementType<any>;
    onError?: (error: Error, errorInfo: React$1.ErrorInfo) => void;
}
declare const SaasContext: React$1.Context<SaasContextValue>;
interface SaasProviderProps extends ChakraProviderProps {
    theme?: Dict;
    linkComponent?: React$1.ElementType<any>;
    children: React$1.ReactNode;
    onError?: (error: Error, errorInfo: React$1.ErrorInfo) => void;
}
declare function SaasProvider(props: SaasProviderProps): react_jsx_runtime.JSX.Element;
declare const useSaas: () => SaasContextValue;

declare function useLink(): React__default.ElementType<any>;

interface ErrorBoundaryProps {
    fallback?: React$1.ReactNode;
    children: React$1.ReactNode;
    onError?: (error: Error, errorInfo: React$1.ErrorInfo) => void;
}
interface ErrorBoundaryState {
    error?: Error | null;
    errorInfo?: any;
}
/**
 * A container component that catches errors and displays a fallback UI.
 *
 * @see Docs https://saas-ui.dev/docs/components/utils/error-boundary
 */
declare class ErrorBoundary extends React$1.Component<ErrorBoundaryProps> {
    state: ErrorBoundaryState;
    static contextType: React$1.Context<SaasContextValue>;
    context: React$1.ContextType<typeof SaasContext>;
    constructor(props: ErrorBoundaryProps);
    static getDerivedStateFromError(error: Error): {
        error: Error;
    };
    onError: (error: Error, errorInfo: any) => void;
    componentDidCatch(error: Error, errorInfo: any): void;
    render(): string | number | boolean | Iterable<React$1.ReactNode> | react_jsx_runtime.JSX.Element | null | undefined;
}

interface AppShellProps extends HTMLChakraProps<'div'>, ThemingProps<'SuiAppShell'> {
    /**
     * The top header navigation
     */
    navbar?: React$1.ReactNode;
    /**
     * Main sidebar, positioned on the left
     */
    sidebar?: React$1.ReactElement;
    /**
     * Secondary sidebar, positioned on the right
     */
    aside?: React$1.ReactNode;
    /**
     * The footer
     */
    footer?: React$1.ReactNode;
    /**
     * The main content
     */
    children: React$1.ReactNode;
    mainRef?: React$1.RefObject<HTMLDivElement>;
}
/**
 * The App Shell defines the main structure of your app.
 *
 * @see Docs https://saas-ui.dev/docs/components/layout/app-shell
 */
declare const AppShell: _chakra_ui_react.ComponentWithAs<"div", AppShellProps>;

declare function CheckIcon(props: IconProps): react_jsx_runtime.JSX.Element;
declare function InfoIcon(props: IconProps): react_jsx_runtime.JSX.Element;
declare function WarningIcon(props: IconProps): react_jsx_runtime.JSX.Element;

type BannerMotion = 'slideOutTop' | 'slideOutBottom' | 'fade' | 'scale' | 'none';
interface BannerTransitionProps extends Omit<HTMLMotionProps<'div'>, 'color' | 'transition'>, ChakraProps {
    motionPreset: BannerMotion;
}

declare const STATUSES: {
    info: {
        icon: typeof InfoIcon;
        colorScheme: string;
    };
    warning: {
        icon: typeof WarningIcon;
        colorScheme: string;
    };
    success: {
        icon: typeof CheckIcon;
        colorScheme: string;
    };
    error: {
        icon: typeof WarningIcon;
        colorScheme: string;
    };
};
type BannerStatus = keyof typeof STATUSES;
interface BannerOptions {
    /**
     * The status of the banner.
     */
    status?: BannerStatus;
    /**
     * Show or hide the banner.
     */
    isOpen?: boolean;
    /**
     * Callback fired when the close button is clicked.
     */
    onClose?: () => void;
    /**
     * Customize the close animation.
     * @default 'slideOutTop'
     * @type 'slideOutTop', 'slideOutBottom', 'fade', 'scale', 'none'
     */
    motionPreset?: BannerMotion;
}
interface BannerProps extends Omit<BannerTransitionProps, 'motionPreset'>, BannerOptions, ThemingProps<'SuiBanner'> {
}
/**
 * Banner is used to communicate the state or status of a
 * page, feature or action
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/banner
 */
declare const Banner: ComponentWithAs<"div", BannerProps>;
interface BannerContentProps extends HTMLChakraProps<'div'> {
}
/**
 * The wrapper for the banner title and description.
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/banner
 */
declare const BannerContent: ComponentWithAs<"div", BannerContentProps>;
interface BannerTitleProps extends HTMLChakraProps<'div'> {
}
/**
 * The title of the banner to be announced by screen readers.
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/banner
 */
declare const BannerTitle: ComponentWithAs<"div", BannerTitleProps>;
interface BannerDescriptionProps extends HTMLChakraProps<'div'> {
}
interface BannerDescriptionProps extends HTMLChakraProps<'div'> {
}
/**
 * The description of the banner to be announced by screen readers.
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/banner
 */
declare const BannerDescription: ComponentWithAs<"div", BannerDescriptionProps>;
interface BannerActionsProps extends HTMLChakraProps<'div'>, ButtonGroupProps {
}
/**
 * The banner actions, renders a ButtonGroup.
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/banner
 */
declare const BannerActions: ComponentWithAs<"div", BannerActionsProps>;
interface BannerIconProps extends HTMLChakraProps<'span'> {
    icon?: As;
}
/**
 * The visual icon for the banner.
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/banner
 */
declare const BannerIcon: React$1.FC<BannerIconProps>;
/**
 * The close button.
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/banner
 */
declare const BannerCloseButton: ComponentWithAs<"button", CloseButtonProps>;

declare const CollapseProvider: React$1.Provider<UseCollapseReturn>;
declare const useCollapseContext: () => UseCollapseReturn;
interface UseCollapse {
    defaultIsOpen?: boolean;
    isOpen?: boolean;
    onOpen?: () => void;
    onClose?: () => void;
    isCollapsible?: boolean;
}
declare const useCollapse: (props?: UseCollapse) => {
    isCollapsible: boolean;
    isOpen: boolean;
    getToggleProps: PropGetter;
    getCollapseProps: (props?: any) => any;
    onToggle: () => void;
    onOpen: () => void;
    onClose: () => void;
};
interface UseCollapseReturn extends ReturnType<typeof useCollapse> {
}

interface StructuredListOptions {
    /**
     * An array of list items
     */
    items?: Array<StructuredListItemProps>;
}
interface StructuredListProps extends StructuredListOptions, HTMLChakraProps<'ul'>, ThemingProps<'SuiStructuredList'> {
}
/**
 * React component to render lists of data
 */
declare const StructuredList: _chakra_ui_react.ComponentWithAs<"ul", StructuredListProps>;
interface StructuredListHeaderProps extends HTMLChakraProps<'li'> {
    /**
     * Action rendered next to the title
     */
    action?: React$1.ReactNode;
    /**
     * The aria-level
     */
    level?: number;
}
declare const StructuredListHeader: _chakra_ui_react.ComponentWithAs<"li", StructuredListHeaderProps>;
interface StructuredListItemProps extends HTMLChakraProps<'li'> {
    onClick?: (e: React$1.MouseEvent) => void;
    href?: string | object;
    isDisabled?: boolean;
}
/**
 * Adding `onClick` or `href` props will wrap the content in a `StructuredListButton`
 */
declare const StructuredListItem: _chakra_ui_react.ComponentWithAs<"li", StructuredListItemProps>;
interface StructuredListButtonProps extends HTMLChakraProps<'div'> {
    onClick?: (e: React$1.MouseEvent) => void;
    as?: As;
    isDisabled?: boolean;
}
/**
 * Behaves like a button by default.
 * Use the 'as' prop to render a link.
 *
 * <StructuredListItemButton as="a" href="/page" />
 *
 * or
 *
 * <StructuredListItemButton as={Link} href={{path: '/page}} />
 */
declare const StructuredListButton: _chakra_ui_react.ComponentWithAs<"div", StructuredListButtonProps>;
interface StructuredListIconProps extends HTMLChakraProps<'div'> {
    /**
     * The icon size
     * @default 5
     */
    size?: SystemProps['boxSize'];
    /**
     * The icon spacing, ltr supported
     */
    spacing?: SystemProps['margin'];
}
declare const StructuredListIcon: React$1.FC<StructuredListIconProps>;
interface StructuredListCellProps extends HTMLChakraProps<'div'> {
}
declare const StructuredListCell: React$1.FC<StructuredListCellProps>;

/**
 * Chakra UI `Link` component wrapped in a router specific link component.
 * Falls back to a plain `Link` if no Saas UI context is available or no `linkComponent` is configured
 * The router link component can be configured in `SaasProvider`.
 * @see https://saas-ui.dev/docs/core/getting-started
 */
declare const Link: _chakra_ui_react.ComponentWithAs<"a", LinkProps>;

type Variants$1 = 'fill' | 'overlay' | 'fullscreen';
interface LoadingOverlayProps extends HTMLChakraProps<'div'>, ThemingProps<'SuiLoadingOverlay'> {
    /**
     * Show or hide the LoadingOverlay.
     * @default true
     */
    isLoading?: boolean;
    /**
     * The transition that should be used for the overlay
     * @default "fade"
     */
    motionPreset?: 'none' | 'fade';
    /**
     * Spacing between children
     */
    spacing?: SystemProps['margin'];
    /**
     * @type "fill" | "overlay" | "fullscreen"
     * @default "fill"
     */
    variant?: 'SuiLoadingOverlay' extends keyof ThemeTypings['components'] ? ThemeTypings['components']['SuiLoadingOverlay']['variants'] : Variants$1;
}
declare const LoadingOverlay: React__default.FC<LoadingOverlayProps>;
declare const LoadingSpinner: _chakra_ui_react.ComponentWithAs<"div", SpinnerProps>;
type LoadingSpinnerProps = SpinnerProps;
interface LoadingTextProps extends HTMLChakraProps<'p'> {
}
declare const LoadingText: React__default.FC<LoadingTextProps>;

interface OverflowMenuProps extends Omit<MenuProps, 'size'> {
    /**
     * The button (aria) label.
     */
    label?: string;
    /**
     * The MenuButton variant.
     */
    variant?: 'Button' extends keyof ThemeTypings['components'] ? ThemeTypings['components']['Button']['variants'] : string;
    /**
     * The MenuButton size
     */
    size?: 'IconButton' extends keyof ThemeTypings['components'] ? ThemeTypings['components']['IconButton']['sizes'] : string;
    /**
     * Props passed to the MenuList.
     */
    menuListProps?: MenuListProps;
    /**
     * Render a custom icon.
     */
    icon?: React$1.ReactElement;
    children: React$1.ReactNode;
}
declare const OverflowMenu: React$1.FC<OverflowMenuProps>;

type Anchor = {
    x: number;
    y: number;
};
interface UseContextMenuReturn {
    isOpen: boolean;
    anchor: Anchor;
    triggerRef: React$1.RefObject<HTMLSpanElement>;
    menuRef: React$1.RefObject<HTMLDivElement>;
    onClose: () => void;
    onOpen: (event: AnyPointerEvent) => void;
}
declare const ContextMenuProvider: React$1.Provider<UseContextMenuReturn>;
declare const useContextMenuContext: () => UseContextMenuReturn;
interface UseContextMenuProps extends ContextMenuProps {
    onClose?: () => void;
}
declare const useContextMenu: (props: UseContextMenuProps) => {
    isOpen: boolean;
    anchor: Anchor;
    triggerRef: React$1.RefObject<HTMLSpanElement>;
    menuRef: React$1.RefObject<HTMLDivElement>;
    onClose: () => void;
    onOpen: (event: AnyPointerEvent) => void;
};
interface ContextMenuProps extends MenuProps {
}
declare const ContextMenu: React$1.FC<ContextMenuProps>;
interface ContextMenuTriggerProps extends HTMLChakraProps<'span'> {
    /**
     * If `true`, the long press gesture is disabled.
     */
    longPressDisabled?: boolean;
}
declare const ContextMenuTrigger: _chakra_ui_react.ComponentWithAs<"span", ContextMenuTriggerProps>;
interface ContextMenuListProps extends MenuListProps {
}
declare const ContextMenuList: React$1.FC<ContextMenuListProps>;
declare const ContextMenuItem: _chakra_ui_react.ComponentWithAs<"button", _chakra_ui_react.MenuItemProps>;

interface PresenceOptions {
    [presence: string]: {
        label: string;
        color: string;
    };
}
/**
 * The presence configuration object.
 *
 * Default presence values: online, offline, busy, dnd, away
 *
 * You can overwrite colors in the theme semantic tokens.
 * theme.semanticTokens.colors['presence.online'] = 'cyan.500'
 *
 * Or add a custom presence value
 * theme.semanticTokens.colors['presence.vacay'] = 'blue.500'
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const Presence: PresenceOptions;
/**
 * Fallback when theme tokens aren't configured
 */
declare const defaultPresenceTokens: {
    online: string;
    offline: string;
    busy: string;
    dnd: string;
    away: string;
};
interface PersonaOptions {
    /**
     * The name of the person in the avatar.
     *
     * - if `src` has loaded, the name will be used as the `alt` attribute of the `img`
     * - If `src` is not loaded, the name will be used to create the initials
     */
    name?: string;
    /**
     * The presence status of the person
     *
     * If set will add an AvatarBadge with color configured in `Presence`
     * Default presence options:
     * - online
     * - offline
     * - busy
     * - dnd
     * - away
     */
    presence?: string;
    /**
     * The icon shown in the AvatarBadge
     */
    presenceIcon?: React$1.ReactNode;
    /**
     * Indicates that a person is out of office. Changes the presence badge style.
     */
    isOutOfOffice?: boolean;
    /**
     * Primary label of the persona, defaults to the name
     */
    label?: React$1.ReactNode;
    /**
     * Secondary label, usually the role of the person
     * Only visible from md size and up.
     */
    secondaryLabel?: React$1.ReactNode;
    /**
     * Tertiary label, usually the status of the person.
     * Only visible from lg size and up.
     */
    tertiaryLabel?: React$1.ReactNode;
    /**
     * Hide the persona details next to the avatar.
     */
    hideDetails?: boolean;
}
interface PersonaProps extends PersonaOptions, Omit<PresenceAvatarProps, 'size' | 'variant'>, ThemingProps<'SuiPersona'> {
}
/**
 * The wrapper component that handles default composition.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const Persona: React$1.FC<PersonaProps>;
interface PersonaContainerProps extends HTMLChakraProps<'div'>, ThemingProps<'SuiPersona'> {
}
/**
 * The container component that provides context and styles.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const PersonaContainer: _chakra_ui_react.ComponentWithAs<"div", PersonaContainerProps>;
interface PresenceAvatarOptions {
    /**
     * The name of the person in the avatar.
     *
     * - if `src` has loaded, the name will be used as the `alt` attribute of the `img`
     * - If `src` is not loaded, the name will be used to create the initials
     */
    name?: string;
    /**
     * The presence status of the person
     *
     * If set will add an AvatarBadge with color configured in `Presence`
     * Default presence options:
     * - online
     * - offline
     * - busy
     * - dnd
     * - away
     */
    presence?: string;
    /**
     * The textual presence status of the person.
     * Online, Offline, Busy, Do-not-disturb or Away
     */
    presenceLabel?: string;
    /**
     * The icon shown in the AvatarBadge
     */
    presenceIcon?: React$1.ReactNode;
    /**
     * The badge size. Defaults to 1em. Use em value to keep the size relative to the avatar.
     */
    badgeSize?: SystemProps['boxSize'];
    /**
     * Indicates that a person is out of office. Changes the presence badge style.
     */
    isOutOfOffice?: boolean;
}
interface PresenceAvatarProps extends PresenceAvatarOptions, AvatarProps {
}
/**
 * An avatar with optional status badge.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const PersonaAvatar: _chakra_ui_react.ComponentWithAs<"span", PresenceAvatarProps>;
/**
 * Wrapper component for the labels.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const PersonaDetails: _chakra_ui_react.ComponentWithAs<"div", PersonaProps>;
/**
 * The main label, usually a name.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const PersonaLabel: _chakra_ui_react.ComponentWithAs<"span", HTMLChakraProps<"span">>;
/**
 * The secondary label, usually the role of a person.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const PersonaSecondaryLabel: _chakra_ui_react.ComponentWithAs<"span", HTMLChakraProps<"span">>;
/**
 * The tertiary label, typically a status message.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/persona
 */
declare const PersonaTertiaryLabel: _chakra_ui_react.ComponentWithAs<"span", HTMLChakraProps<"span">>;

interface PropertyOptions {
    label?: React$1.ReactNode;
    value?: React$1.ReactNode;
    labelWidth?: SystemProps['width'];
    spacing?: SystemProps['margin'];
}
interface PropertyProps extends PropertyOptions, HTMLChakraProps<'dl'>, ThemingProps<'SuiProperty'> {
}
/**
 * The wrapper component that handles default composition.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/property
 */
declare const Property: _chakra_ui_react.ComponentWithAs<"dl", PropertyProps>;
interface PropertyLabelProps extends HTMLChakraProps<'dt'> {
}
/**
 * The property label.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/property
 */
declare const PropertyLabel: _chakra_ui_react.ComponentWithAs<"dt", PropertyProps>;
interface PropertyValueProps extends HTMLChakraProps<'dd'> {
}
/**
 * The property value.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/property
 */
declare const PropertyValue: _chakra_ui_react.ComponentWithAs<"dd", PropertyValueProps>;
interface PropertyListProps extends Omit<ListProps, 'items'> {
}
/**
 * Render a list of properties.
 * Will set the `as` prop of it's children to `div`,
 * in order to render a semantically correct `dl` list.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/property
 */
declare const PropertyList: React$1.FC<PropertyListProps>;

interface UseNavbarProps {
    /**
     * Ref to the DOM node.
     */
    ref: React__default.ForwardedRef<HTMLElement>;
    /**
     * The parent element where the navbar is placed within.
     * This is used to determine the scroll position and whether the navbar should be hidden or not.
     * @default `window`
     */
    parentRef?: React__default.RefObject<HTMLElement>;
    /**
     * The height of the navbar.
     * @default "3.5rem" (56px)
     */
    height?: number | string;
    /**
     * Whether the navbar should hide on scroll or not.
     * @default false
     */
    shouldHideOnScroll?: boolean;
    /**
     * Whether the navbar parent scroll event should be listened to or not.
     * @default false
     */
    disableScrollHandler?: boolean;
    /**
     * The props to modify the framer motion animation. Use the `variants` API to create your own animation.
     * This motion is only available if the `shouldHideOnScroll` prop is set to `true`.
     */
    motionProps?: HTMLMotionProps<'nav'>;
    /**
     * The scroll event handler for the navbar. The event fires when the navbar parent element is scrolled.
     * it only works if `disableScrollHandler` is set to `false` or `shouldHideOnScroll` is set to `true`.
     */
    onScrollPositionChange?: (scrollPosition: number) => void;
    /**
     * Style props to be applied to the navbar container.
     */
    style?: React__default.CSSProperties;
}
declare function useNavbar(props: UseNavbarProps): {
    containerRef: React__default.RefObject<HTMLElement>;
    height: string | number;
    isHidden: boolean;
    shouldHideOnScroll: boolean;
    motionProps: HTMLMotionProps<"nav"> | undefined;
    getContainerProps: PropGetterV2<any>;
};

type MotionProps = Pick<HTMLMotionProps<'div'>, 'onAnimationStart' | 'onDrag' | 'onDragStart' | 'onDragEnd'>;
interface NavbarProps extends Omit<UseNavbarProps, 'hideOnScroll' | 'ref'>, Omit<HTMLChakraProps<'div'>, keyof MotionProps | 'height'>, MotionProps, ThemingProps<'SuiNavbar'> {
    children?: React.ReactNode | React.ReactNode[];
}
declare const Navbar: _chakra_ui_react.ComponentWithAs<"div", NavbarProps>;

interface NavbarBrandProps extends HTMLChakraProps<'div'> {
    children?: React.ReactNode | React.ReactNode[];
}
declare const NavbarBrand: _chakra_ui_react.ComponentWithAs<"div", NavbarBrandProps>;

interface NavbarContentProps extends HTMLChakraProps<'ul'> {
    /**
     * Typically the `NavbarItem` component
     */
    children?: React.ReactNode | React.ReactNode[];
    /**
     * Spacing between each navbar item
     */
    spacing?: SystemProps['margin'];
}
declare const NavbarContent: _chakra_ui_react.ComponentWithAs<"ul", NavbarContentProps>;

interface NavbarItemProps extends HTMLChakraProps<'li'> {
    children?: React.ReactNode;
    /**
     * Whether the item is active or not.
     * @default false
     */
    isActive?: boolean;
}
declare const NavbarItem: _chakra_ui_react.ComponentWithAs<"li", NavbarItemProps>;

declare const NavbarProvider: React$1.Provider<{
    containerRef: React$1.RefObject<HTMLElement>;
    height: string | number;
    isHidden: boolean;
    shouldHideOnScroll: boolean;
    motionProps: framer_motion.HTMLMotionProps<"nav"> | undefined;
    getContainerProps: _chakra_ui_react_utils.PropGetterV2<any>;
}>;
declare const useNavbarContext: () => {
    containerRef: React$1.RefObject<HTMLElement>;
    height: string | number;
    isHidden: boolean;
    shouldHideOnScroll: boolean;
    motionProps: framer_motion.HTMLMotionProps<"nav"> | undefined;
    getContainerProps: _chakra_ui_react_utils.PropGetterV2<any>;
};

interface NavbarLinkProps extends HTMLChakraProps<'a'> {
    children?: React.ReactNode;
    /**
     * Whether the link is active or not.
     * @default false
     */
    isActive?: boolean;
}
declare const NavbarLink: _chakra_ui_react.ComponentWithAs<"li", NavbarLinkProps>;

interface SidebarOptions {
    /**
     * Spacing between child elements.
     */
    spacing?: SystemProps['margin'];
    /**
     * Define the for the mobile nav. Use `false` to disable the mobile nav.
     *
     * @default "lg"
     */
    toggleBreakpoint?: false | 'sm' | 'md' | 'lg' | 'xl' | '2xl';
    /**
     * Control the visibility of the sidebar.
     */
    isOpen?: boolean;
    /**
     * Callback invoked when the sidebar is opened.
     */
    onOpen?: () => void;
    /**
     * Callback invoked when the sidebar is closed.
     */
    onClose?: () => void;
    /**
     * The transition used when opening and closing the sidebar.
     */
    motionPreset?: 'slideInOut' | 'none';
}
interface SidebarProps extends SidebarOptions, Pick<HTMLMotionProps<'div'>, 'onAnimationStart' | 'onDrag' | 'onDragStart' | 'onDragEnd'>, Omit<HTMLChakraProps<'div'>, 'css' | 'onAnimationStart' | 'onDrag' | 'onDragStart' | 'onDragEnd'>, ThemingProps<'SuiSidebar'> {
}
interface SidebarToggleButtonProps extends Omit<IconButtonProps, 'aria-label' | 'icon'> {
    icon?: MaybeRenderProp<{
        isOpen: boolean;
    }>;
}
interface SidebarSectionProps extends HTMLChakraProps<'div'> {
    direction?: SystemProps['flexDirection'];
}
interface SidebarOverlayProps extends ChakraProps$1 {
}

/**
 * Side navigation, commonly used as the primary navigation
 *
 * @see Docs https://saas-ui.dev/docs/components/layout/sidebar
 */
declare const Sidebar: _chakra_ui_react.ComponentWithAs<"nav", SidebarProps>;
/**
 * Button that toggles the sidebar visibility.
 *
 * @see Docs https://saas-ui.dev/docs/components/layout/sidebar
 */
declare const SidebarToggleButton: React$1.FC<SidebarToggleButtonProps>;
/**
 * Overlay shown when sidebar is open on mobile.
 *
 * @see Docs https://saas-ui.dev/docs/components/layout/sidebar
 */
declare const SidebarOverlay: React$1.FC<SidebarOverlayProps>;
/**
 * Sidebar section that can contain sidebar items.
 *
 * @see Docs https://saas-ui.dev/docs/components/layout/sidebar
 */
declare const SidebarSection: React$1.FC<SidebarSectionProps>;

interface NavProps extends HTMLChakraProps<'nav'> {
    orientation?: 'vertical' | 'horizontal';
    spacing?: StackProps['spacing'];
}
declare const Nav: React$1.FC<NavProps>;

interface NavGroupTitleProps extends HTMLChakraProps<'div'> {
    leftIcon?: React$1.ReactElement;
    collapseIcon?: MaybeRenderProp<{
        isOpen: boolean;
    }>;
    isCollapsible?: boolean;
}
declare const NavGroupTitle: React$1.FC<NavGroupTitleProps>;
interface NavGroupProps extends Omit<HTMLChakraProps<'div'>, 'title'>, ThemingProps<'SuiNavGroup'> {
    title?: React$1.ReactNode;
    isCollapsible?: boolean;
    defaultIsOpen?: boolean;
    onOpen?: () => void;
    onClose?: () => void;
    icon?: React$1.ReactElement;
}
declare const NavGroupContent: React$1.FC<HTMLChakraProps<'div'>>;
/**
 * Navigation group containing nav items, used in Sidebar.
 *
 * @see Docs https://saas-ui.dev/docs/components/layout/sidebar
 */
declare const NavGroup: React$1.FC<NavGroupProps>;

interface NavItemLabelProps extends HTMLChakraProps<'span'> {
}
declare const NavItemLabel: _chakra_ui_react.ComponentWithAs<"span", NavItemLabelProps>;
interface NavItemProps extends HTMLChakraProps<'a'>, ThemingProps<'SuiNavItem'> {
    /**
     * The href attribute of the nav item,
     * will be wrapped in a `Link`, if `linkComponent` is configured in SaasProvider.
     */
    href?: string;
    /**
     * Icon to be displayed in the nav item
     */
    icon?: React$1.ReactElement;
    /**
     * Inset of the item, used for nested items
     */
    inset?: SystemProps['paddingLeft'];
    /**
     * Props to be passed to the tooltip
     * @see Docs https://chakra-ui.com/docs/overlay/tooltip
     */
    tooltipProps?: Omit<TooltipProps, 'children'>;
    /**
     * If `true`, the nav item will be active
     */
    isActive?: boolean;
}
/**
 * Navigation item used in the sidebar.
 *
 * @see Docs https://saas-ui.dev/docs/components/layout/sidebar
 */
declare const NavItem: _chakra_ui_react.ComponentWithAs<"a", NavItemProps>;

declare const NavGroupStylesProvider: React$1.Provider<Record<string, SystemStyleObject>>;
declare const useNavGroupStyles: () => Record<string, SystemStyleObject>;
declare const NavItemStylesProvider: React$1.Provider<Record<string, SystemStyleObject>>;
declare const useNavItemStyles: () => Record<string, SystemStyleObject>;

declare const SidebarStylesProvider: React$1.Provider<Record<string, SystemStyleObject>>;
declare const useSidebarStyles: () => Record<string, SystemStyleObject>;

type Variants = 'compact' | 'default';
interface UseSidebarReturn extends UseDisclosureReturn {
    isMobile?: boolean;
    breakpoints?: ResponsiveValue<boolean>;
    variant?: 'Sidebar' extends keyof ThemeTypings['components'] ? ThemeTypings['components']['Sidebar']['variants'] : Variants;
    size?: 'Sidebar' extends keyof ThemeTypings['components'] ? ThemeTypings['components']['Sidebar']['sizes'] : string;
}
declare const SidebarProvider: React$1.Provider<UseSidebarReturn>;
declare const useSidebarContext: () => UseSidebarReturn;
declare const useSidebarToggleButton: () => {
    isOpen: boolean;
    isMobile: boolean | undefined;
    getButtonProps: PropGetter;
};

interface SearchInputProps extends ThemingProps<'SuiSearchInput'>, Omit<InputProps, 'size' | 'variant'> {
    /**
     * The placeholder text for the input
     * @type string
     * @default Search
     */
    placeholder?: string;
    /**
     * The icon to render before the input text
     * @type React.ReactElement
     */
    icon?: React$1.ReactElement;
    /**
     * The icon to render in the reset button
     * @type React.ReactElement
     */
    resetIcon?: React$1.ReactElement;
    /**
     * Right element rendered when the value is empty
     * @type React.ReactElement
     */
    rightElement?: React$1.ReactElement;
    /**
     * Callback to trigger when the reset button is clicked or escape key is pressed
     */
    onReset?: () => void;
}
declare const SearchInput: _chakra_ui_react.ComponentWithAs<"input", SearchInputProps>;

interface SnackbarProps extends Omit<AlertProps, 'id' | 'title' | 'position'> {
    id?: ToastId;
    title?: React$1.ReactNode;
    icon?: React$1.ReactNode;
    action?: React$1.ReactNode;
    description?: React$1.ReactNode;
    position?: ToastPosition;
    isClosable?: boolean;
    onClose?: () => void;
}
declare const Snackbar: React$1.FC<SnackbarProps>;
interface UseSnackbarOptions extends UseToastOptions {
    icon?: React$1.ReactNode;
    action?: React$1.ReactNode;
    variant?: 'snackbar' | 'subtle' | 'solid' | 'left-accent' | 'top-accent' | string;
}
type SnackbarOptions = UseSnackbarOptions | string;
interface SnackbarPromiseOptions {
    loading?: SnackbarOptions;
    success: SnackbarOptions | ((data: any) => SnackbarOptions);
    error: SnackbarOptions | ((error: any) => SnackbarOptions);
}
/**
 * The snackbar component is used to give feedback after certain actions.
 *
 * @see Docs https://saas-ui.dev/docs/components/feedback/snackbar
 */
declare function useSnackbar(defaultOptions?: UseSnackbarOptions): {
    (options: SnackbarOptions): ToastId;
    info(options: SnackbarOptions): ToastId;
    success(options: SnackbarOptions): ToastId;
    error(options: SnackbarOptions): ToastId;
    /**
     * A utility function to show a loading spinner while a promise resolves.
     * `success` and `error` accept an optional function that receives the result or error of the promise.
     *
     * if `error` is a function, it will not throw the error, and you can handle it in the callback function.
     */
    promise(promise: Promise<unknown>, { loading, success, error }: SnackbarPromiseOptions): Promise<unknown>;
    update(toastId: ToastId, options: UseToastOptions): void;
    isActive: (id: ToastId) => boolean;
    close: (id: ToastId) => void;
    closeAll: (options?: _chakra_ui_toast_dist_toast_types_24f022fd.C | undefined) => void;
};
type UseSnackbarReturn = ReturnType<typeof useSnackbar>;

declare const createStandAloneSnackbar: (options: CreateStandAloneToastParam) => {
    SnackbarContainer: () => JSX.Element;
    snackbar: {
        (options?: _chakra_ui_react.UseToastOptions | undefined): _chakra_ui_react.ToastId;
        update(id: _chakra_ui_react.ToastId, options: Omit<_chakra_ui_react.UseToastOptions, "id">): void;
        promise<Result extends unknown, Err extends Error = Error>(promise: Promise<Result>, options: {
            success: {
                title?: React$1.ReactNode;
                position?: _chakra_ui_react.ToastPosition | undefined;
                id?: _chakra_ui_react.ToastId | undefined;
                colorScheme?: (string & {}) | "whiteAlpha" | "blackAlpha" | "gray" | "red" | "orange" | "yellow" | "green" | "teal" | "blue" | "cyan" | "purple" | "pink" | "linkedin" | "facebook" | "messenger" | "whatsapp" | "twitter" | "telegram" | "primary" | "secondary" | "indigo" | undefined;
                variant?: _chakra_ui_styled_system.ResponsiveValue<(string & {}) | "solid" | "subtle" | "left-accent" | "top-accent" | "snackbar"> | undefined;
                size?: _chakra_ui_styled_system.ResponsiveValue<string & {}> | undefined;
                orientation?: "horizontal" | "vertical" | undefined;
                styleConfig?: Record<string, any> | undefined;
                icon?: React$1.ReactNode;
                description?: React$1.ReactNode;
                isClosable?: boolean | undefined;
                duration?: number | null | undefined;
                render?: ((props: _chakra_ui_toast_dist_toast_types_24f022fd.R) => React$1.ReactNode) | undefined;
                onCloseComplete?: (() => void) | undefined;
                containerStyle?: _chakra_ui_styled_system.StyleProps | undefined;
            } | ((args_0: Result) => {
                title?: React$1.ReactNode;
                position?: _chakra_ui_react.ToastPosition | undefined;
                id?: _chakra_ui_react.ToastId | undefined;
                colorScheme?: (string & {}) | "whiteAlpha" | "blackAlpha" | "gray" | "red" | "orange" | "yellow" | "green" | "teal" | "blue" | "cyan" | "purple" | "pink" | "linkedin" | "facebook" | "messenger" | "whatsapp" | "twitter" | "telegram" | "primary" | "secondary" | "indigo" | undefined;
                variant?: _chakra_ui_styled_system.ResponsiveValue<(string & {}) | "solid" | "subtle" | "left-accent" | "top-accent" | "snackbar"> | undefined;
                size?: _chakra_ui_styled_system.ResponsiveValue<string & {}> | undefined;
                orientation?: "horizontal" | "vertical" | undefined;
                styleConfig?: Record<string, any> | undefined;
                icon?: React$1.ReactNode;
                description?: React$1.ReactNode;
                isClosable?: boolean | undefined;
                duration?: number | null | undefined;
                render?: ((props: _chakra_ui_toast_dist_toast_types_24f022fd.R) => React$1.ReactNode) | undefined;
                onCloseComplete?: (() => void) | undefined;
                containerStyle?: _chakra_ui_styled_system.StyleProps | undefined;
            });
            error: {
                title?: React$1.ReactNode;
                position?: _chakra_ui_react.ToastPosition | undefined;
                id?: _chakra_ui_react.ToastId | undefined;
                colorScheme?: (string & {}) | "whiteAlpha" | "blackAlpha" | "gray" | "red" | "orange" | "yellow" | "green" | "teal" | "blue" | "cyan" | "purple" | "pink" | "linkedin" | "facebook" | "messenger" | "whatsapp" | "twitter" | "telegram" | "primary" | "secondary" | "indigo" | undefined;
                variant?: _chakra_ui_styled_system.ResponsiveValue<(string & {}) | "solid" | "subtle" | "left-accent" | "top-accent" | "snackbar"> | undefined;
                size?: _chakra_ui_styled_system.ResponsiveValue<string & {}> | undefined;
                orientation?: "horizontal" | "vertical" | undefined;
                styleConfig?: Record<string, any> | undefined;
                icon?: React$1.ReactNode;
                description?: React$1.ReactNode;
                isClosable?: boolean | undefined;
                duration?: number | null | undefined;
                render?: ((props: _chakra_ui_toast_dist_toast_types_24f022fd.R) => React$1.ReactNode) | undefined;
                onCloseComplete?: (() => void) | undefined;
                containerStyle?: _chakra_ui_styled_system.StyleProps | undefined;
            } | ((args_0: Err) => {
                title?: React$1.ReactNode;
                position?: _chakra_ui_react.ToastPosition | undefined;
                id?: _chakra_ui_react.ToastId | undefined;
                colorScheme?: (string & {}) | "whiteAlpha" | "blackAlpha" | "gray" | "red" | "orange" | "yellow" | "green" | "teal" | "blue" | "cyan" | "purple" | "pink" | "linkedin" | "facebook" | "messenger" | "whatsapp" | "twitter" | "telegram" | "primary" | "secondary" | "indigo" | undefined;
                variant?: _chakra_ui_styled_system.ResponsiveValue<(string & {}) | "solid" | "subtle" | "left-accent" | "top-accent" | "snackbar"> | undefined;
                size?: _chakra_ui_styled_system.ResponsiveValue<string & {}> | undefined;
                orientation?: "horizontal" | "vertical" | undefined;
                styleConfig?: Record<string, any> | undefined;
                icon?: React$1.ReactNode;
                description?: React$1.ReactNode;
                isClosable?: boolean | undefined;
                duration?: number | null | undefined;
                render?: ((props: _chakra_ui_toast_dist_toast_types_24f022fd.R) => React$1.ReactNode) | undefined;
                onCloseComplete?: (() => void) | undefined;
                containerStyle?: _chakra_ui_styled_system.StyleProps | undefined;
            });
            loading: {
                title?: React$1.ReactNode;
                position?: _chakra_ui_react.ToastPosition | undefined;
                id?: _chakra_ui_react.ToastId | undefined;
                colorScheme?: (string & {}) | "whiteAlpha" | "blackAlpha" | "gray" | "red" | "orange" | "yellow" | "green" | "teal" | "blue" | "cyan" | "purple" | "pink" | "linkedin" | "facebook" | "messenger" | "whatsapp" | "twitter" | "telegram" | "primary" | "secondary" | "indigo" | undefined;
                variant?: _chakra_ui_styled_system.ResponsiveValue<(string & {}) | "solid" | "subtle" | "left-accent" | "top-accent" | "snackbar"> | undefined;
                size?: _chakra_ui_styled_system.ResponsiveValue<string & {}> | undefined;
                orientation?: "horizontal" | "vertical" | undefined;
                styleConfig?: Record<string, any> | undefined;
                icon?: React$1.ReactNode;
                description?: React$1.ReactNode;
                isClosable?: boolean | undefined;
                duration?: number | null | undefined;
                render?: ((props: _chakra_ui_toast_dist_toast_types_24f022fd.R) => React$1.ReactNode) | undefined;
                onCloseComplete?: (() => void) | undefined;
                containerStyle?: _chakra_ui_styled_system.StyleProps | undefined;
            };
        }): void;
        closeAll: (options?: _chakra_ui_toast_dist_toast_types_24f022fd.C | undefined) => void;
        close: (id: _chakra_ui_react.ToastId) => void;
        isActive: (id: _chakra_ui_react.ToastId) => boolean;
    };
};

interface StepsProps extends Omit<HTMLChakraProps<'div'>, 'onChange'>, ThemingProps<'Stepper'> {
    /**
     * The orientation of the stepper.
     */
    orientation?: 'horizontal' | 'vertical';
    /**
     * The current step index or name.
     */
    step?: number | string;
    /**
     * The current step index.
     */
    index?: number;
    /**
     * Callback invoked when the step changes.
     */
    onChange?: (index: number) => void;
    /**
     * Props to pass to the stepper component.
     *
     * @see Docs https://chakra-ui.com/docs/feedback/stepper#props
     */
    stepperProps?: StepperProps;
}
/**
 * Wrapper element containing the steps.
 */
declare const Steps: _chakra_ui_react.ComponentWithAs<"div", StepsProps>;
interface StepsItemProps extends Omit<HTMLChakraProps<'div'>, 'title'> {
    /**
     * Custom render function
     */
    render?: (props?: any) => React$1.ReactElement;
    /**
     * The step name
     */
    name?: string;
    /**
     * The step title
     */
    title: React$1.ReactNode;
    /**
     * The step description
     */
    description?: React$1.ReactNode;
    /**
     * Show an icon instead of the step number
     */
    icon?: React$1.ReactNode;
    /**
     * Show the step as active
     */
    isActive?: boolean;
    /**
     * Show the step as completed
     */
    isCompleted?: boolean;
}
declare const StepsItem: React$1.FC<StepsItemProps>;
interface StepperContentProps extends HTMLChakraProps<'div'> {
    /**
     * Show or hide the content, only when orientation is vertical.
     */
    isOpen?: boolean;
    /**
     * The orientation of the stepper.
     */
    orientation?: 'horizontal' | 'vertical';
}
/**
 * Renders the step content, is collapsible.
 */
declare const StepsContent: React$1.FC<StepperContentProps>;
/**
 * Shown when all steps have completed.
 */
declare const StepsCompleted: React$1.FC<HTMLChakraProps<'div'>>;

declare const StepperProvider: React$1.Provider<{
    stepsRef: React$1.MutableRefObject<string[]>;
    activeStep: string;
    activeIndex: number;
    isFirstStep: boolean;
    isLastStep: boolean;
    isCompleted: boolean;
    setIndex: React$1.Dispatch<React$1.SetStateAction<number>>;
    setStep: (name: string) => void;
    nextStep: () => void;
    prevStep: () => void;
    registerStep: (name: string) => void;
    unregisterStep: (name: string) => void;
}>;
declare const useStepperContext: () => {
    stepsRef: React$1.MutableRefObject<string[]>;
    activeStep: string;
    activeIndex: number;
    isFirstStep: boolean;
    isLastStep: boolean;
    isCompleted: boolean;
    setIndex: React$1.Dispatch<React$1.SetStateAction<number>>;
    setStep: (name: string) => void;
    nextStep: () => void;
    prevStep: () => void;
    registerStep: (name: string) => void;
    unregisterStep: (name: string) => void;
};
interface UseStepperProps {
    step?: number | string;
    isCompleted?: boolean;
    onChange?(index: number): void;
}
declare function useStepper(props: UseStepperProps): {
    stepsRef: React$1.MutableRefObject<string[]>;
    activeStep: string;
    activeIndex: number;
    isFirstStep: boolean;
    isLastStep: boolean;
    isCompleted: boolean;
    setIndex: React$1.Dispatch<React$1.SetStateAction<number>>;
    setStep: (name: string) => void;
    nextStep: () => void;
    prevStep: () => void;
    registerStep: (name: string) => void;
    unregisterStep: (name: string) => void;
};
type UseStepperReturn = ReturnType<typeof useStepper>;
interface UseStepProps {
    name?: string;
    isActive?: boolean;
    isCompleted?: boolean;
}
declare function useStep(props: UseStepProps): {
    isActive: boolean | undefined;
    isCompleted: boolean | undefined;
};
/**
 * Returns props for a Prev Button
 */
declare function useStepperPrevButton({ label }?: {
    label?: string | undefined;
}): {
    isDisabled: boolean;
    onClick: () => void;
    children: string;
};
/**
 * Returns props for a Next Button
 */
declare function useStepperNextButton({ label, submitLabel, }?: {
    label?: string | undefined;
    submitLabel?: string | undefined;
}): {
    isDisabled: boolean;
    onClick: () => void;
    children: string;
};

interface Web3AddressProps extends HTMLChakraProps<'span'> {
    address: string;
    startLength?: number;
    endLength?: number;
}
/**
 * Display Web3 addresses in a more readable format.
 *
 * @see Docs https://saas-ui.dev/docs/components/web3/address
 */
declare const Web3Address: React$1.FC<Web3AddressProps>;

declare const useTimelineStyles: () => Record<string, _chakra_ui_styled_system.SystemStyleObject>;
interface TimelineProps extends HTMLChakraProps<'ul'>, ThemingProps<'SuiTimeline'> {
}
/**
 * Display a list of events in chronological order.
 *
 * @see Docs https://saas-ui.dev/docs/components/data-display/timeline
 */
declare const Timeline: React__default.FC<TimelineProps>;
interface TimelineItemProps extends HTMLChakraProps<'li'> {
}
declare const TimelineItem: _chakra_ui_react.ComponentWithAs<"li", TimelineItemProps>;
interface TimelineContentProps extends HTMLChakraProps<'div'> {
}
declare const TimelineContent: React__default.FC<TimelineContentProps>;
interface TimelineSeparatorProps extends HTMLChakraProps<'div'> {
}
declare const TimelineSeparator: React__default.FC<TimelineSeparatorProps>;
interface TimelineDotProps extends HTMLChakraProps<'div'> {
}
declare const TimelineDot: React__default.FC<TimelineDotProps>;
interface TimelineIconProps extends HTMLChakraProps<'div'> {
}
declare const TimelineIcon: React__default.FC<TimelineIconProps>;
interface TimelineTrackProps extends HTMLChakraProps<'div'> {
}
declare const TimelineTrack: React__default.FC<TimelineTrackProps>;

interface CreateIconOptions {
    /**
     * The icon `svg` viewBox
     * @default "0 0 24 24"
     */
    viewBox?: string;
    /**
     * The `svg` path or group element
     * @type React.ReactElement | React.ReactElement[]
     */
    path?: React.ReactElement | React.ReactElement[];
    /**
     * If the `svg` has a single path, simply copy the path's `d` attribute
     */
    d?: string;
    /**
     * The display name useful in the dev tools
     */
    displayName?: string;
    /**
     * Default props automatically passed to the component; overwriteable
     */
    defaultProps?: IconProps$1;
}
declare const createIcon: (props: CreateIconOptions) => _chakra_ui_system.ComponentWithAs<"svg", IconProps$1>;

interface IconBadgeProps extends IconProps, ThemingProps<'SuiIconBadge'> {
    /**
     * The icon to be used in the button.
     * @type React.ReactElement
     */
    icon?: React.ReactElement;
    /**
     * If `true`, the badge will be perfectly round. Else, it'll be slightly round
     *
     * @default false
     */
    isRound?: boolean;
    /**
     * A11y: A label that describes the icon
     */
    'aria-label'?: string;
}
declare const IconBadge: _chakra_ui_react.ComponentWithAs<"div", IconBadgeProps>;

export { AppShell, type AppShellProps, Banner, BannerActions, type BannerActionsProps, BannerCloseButton, BannerContent, type BannerContentProps, BannerDescription, type BannerDescriptionProps, BannerIcon, type BannerIconProps, type BannerProps, type BannerStatus, BannerTitle, type BannerTitleProps, Br, CollapseProvider, Command, ContextMenu, ContextMenuItem, ContextMenuList, type ContextMenuListProps, type ContextMenuProps, ContextMenuProvider, ContextMenuTrigger, type ContextMenuTriggerProps, EmptyState, EmptyStateActions, EmptyStateBody, type EmptyStateBodyProps, EmptyStateContainer, type EmptyStateContainerProps, EmptyStateDescription, EmptyStateFooter, EmptyStateIcon, type EmptyStateProps, EmptyStateTitle, ErrorBoundary, type ErrorBoundaryProps, type ErrorBoundaryState, IconBadge, type IconBadgeProps, Link, LoadingOverlay, type LoadingOverlayProps, LoadingSpinner, type LoadingSpinnerProps, LoadingText, type LoadingTextProps, Nav, NavGroup, NavGroupContent, type NavGroupProps, NavGroupStylesProvider, NavGroupTitle, type NavGroupTitleProps, NavItem, NavItemLabel, type NavItemLabelProps, type NavItemProps, NavItemStylesProvider, type NavProps, Navbar, NavbarBrand, type NavbarBrandProps, NavbarContent, type NavbarContentProps, NavbarItem, type NavbarItemProps, NavbarLink, type NavbarProps, NavbarProvider, OverflowMenu, type OverflowMenuProps, Persona, PersonaAvatar, PersonaContainer, type PersonaContainerProps, PersonaDetails, PersonaLabel, type PersonaProps, PersonaSecondaryLabel, PersonaTertiaryLabel, Presence, type PresenceOptions, Property, PropertyLabel, type PropertyLabelProps, PropertyList, type PropertyListProps, type PropertyProps, PropertyValue, type PropertyValueProps, SaasContext, type SaasContextValue, SaasProvider, type SaasProviderProps, SearchInput, type SearchInputProps, Sidebar, type SidebarOptions, SidebarOverlay, type SidebarOverlayProps, type SidebarProps, SidebarProvider, SidebarSection, type SidebarSectionProps, SidebarStylesProvider, SidebarToggleButton, type SidebarToggleButtonProps, Snackbar, type SnackbarOptions, type SnackbarPromiseOptions, type StepperContentProps, StepperProvider, Steps, StepsCompleted, StepsContent, StepsItem, type StepsItemProps, type StepsProps, StructuredList, StructuredListButton, type StructuredListButtonProps, StructuredListCell, type StructuredListCellProps, StructuredListHeader, type StructuredListHeaderProps, StructuredListIcon, type StructuredListIconProps, StructuredListItem, type StructuredListItemProps, type StructuredListProps, Timeline, TimelineContent, type TimelineContentProps, TimelineDot, type TimelineDotProps, TimelineIcon, type TimelineIconProps, TimelineItem, type TimelineItemProps, type TimelineProps, TimelineSeparator, type TimelineSeparatorProps, TimelineTrack, type TimelineTrackProps, type UseCollapse, type UseCollapseReturn, type UseContextMenuProps, type UseContextMenuReturn, type UseSidebarReturn, type UseSnackbarOptions, type UseSnackbarReturn, type UseStepProps, type UseStepperProps, type UseStepperReturn, Web3Address, type Web3AddressProps, createIcon, createStandAloneSnackbar, defaultPresenceTokens, useCollapse, useCollapseContext, useContextMenu, useContextMenuContext, useEmptyStateStyles, useLink, useNavGroupStyles, useNavItemStyles, useNavbar, useNavbarContext, useSaas, useSidebarContext, useSidebarStyles, useSidebarToggleButton, useSnackbar, useStep, useStepper, useStepperContext, useStepperNextButton, useStepperPrevButton, useTimelineStyles };
