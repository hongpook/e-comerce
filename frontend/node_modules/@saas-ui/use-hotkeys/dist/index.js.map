{"version":3,"sources":["../src/index.ts","../src/provider.tsx","../src/use-hotkeys.ts","../src/use-hotkeys-shortcut.ts","../src/hotkey.tsx","../src/create-hotkeys.tsx"],"sourcesContent":["export { HotkeysProvider, useHotkeysContext } from './provider'\nexport type {\n  HotkeysProviderProps,\n  HotkeysConfig,\n  HotkeysContextValues,\n  HotkeysGroupConfig,\n  HotkeysGroupItems,\n  HotkeysItemConfig,\n} from './provider'\nexport { type UseHotkeysOptions, splitKeys, useHotkeys } from './use-hotkeys'\nexport { useHotkeysShortcut } from './use-hotkeys-shortcut'\nexport { Hotkey } from './hotkey'\nexport type { HotkeyProps } from './hotkey'\nexport { createHotkeys } from './create-hotkeys'\n","import * as React from 'react'\n\nexport interface HotkeysItemConfig {\n  /**\n   * Label describing the function of this keyboard shortcut\n   */\n  label: string\n  /**\n   * The key combination.\n   * Supports shorthands: ⌥ ⇧ ⌃ ⌘\n   *\n   * Shifted keys like ? and + are handled automatically\n   */\n  command: string | string[]\n}\n\nexport interface HotkeysGroupItems {\n  [item: string]: HotkeysItemConfig\n}\n\nexport interface HotkeysGroupConfig {\n  /**\n   * The group title\n   */\n  title?: string\n  /**\n   * Hotkeys in this group\n   */\n  hotkeys: HotkeysGroupItems\n}\n\n/**\n * The hotkeys configuration.\n * Supports shorthands: ⌥ ⇧ ⌃ ⌘\n *\n * Shifted keys like ? and + are handled automatically\n */\nexport interface HotkeysConfig {\n  [group: string]: HotkeysGroupConfig\n}\n\nconst { createContext, useContext } = React\n\nexport interface HotkeysContextValues<\n  Config extends HotkeysConfig = HotkeysConfig,\n> {\n  hotkeys: Config\n}\n\nconst HotkeysContext: any = createContext([])\n\nexport interface HotkeysProviderProps {\n  children: React.ReactNode\n  hotkeys: HotkeysConfig\n}\n\nexport const HotkeysProvider = ({\n  children,\n  hotkeys,\n}: HotkeysProviderProps) => {\n  const value = { hotkeys }\n\n  return (\n    <HotkeysContext.Provider value={value}>{children}</HotkeysContext.Provider>\n  )\n}\n\nexport const useHotkeysContext = (): HotkeysContextValues => {\n  return useContext(HotkeysContext)\n}\n","import * as React from 'react'\n\nconst { useEffect, useCallback, useMemo, useRef } = React\n\n// Works best with US or UK keyboards\nconst shiftedKeys: Record<string, string> = {\n  ')': '0',\n  '!': '1',\n  '@': \"'\",\n  '\"': \"'\",\n  '#': '3',\n  '£': '3',\n  $: '4',\n  '%': '5',\n  '^': '6',\n  '&': '7',\n  '*': '8',\n  '(': '9',\n  '~': '#',\n  _: '-',\n  '+': '=',\n  ':': ';',\n  '<': ',',\n  '>': '.',\n  '?': '/',\n  '|': '\\\\',\n  '{': '[',\n  '}': ']',\n}\n\nconst modifiers: Record<string, string> = {\n  '⌥': 'alt',\n  option: 'alt',\n  '⇧': 'shift',\n  '⌃': 'control',\n  ctrl: 'control',\n  '⌘': 'meta',\n  cmd: 'meta',\n  command: 'meta',\n  mod: 'meta', // ios\n  esc: 'escape',\n}\n\nexport const splitKeys = (keys: string) => {\n  return keys\n    .replace(/\\+/g, (match, offset) => {\n      if (offset === 0) {\n        return match\n      }\n      return ' '\n    })\n    .split(/\\s/)\n}\n\nconst parseKeys = (keys: string | string[]) => {\n  if (typeof keys === 'string') {\n    keys = [keys]\n  }\n  return keys.reduce((memo: Array<string[]>, command: string) => {\n    memo.push(\n      splitKeys(command.toLowerCase()).reduce(\n        (keys: string[], key: string, i, command) => {\n          if (command.length === 1 && shiftedKeys[key]) {\n            return ['shift', shiftedKeys[key]]\n          }\n          if (modifiers[key]) {\n            keys.push(modifiers[key])\n          } else if (key !== 'then') {\n            keys.push(key)\n          }\n          return keys\n        },\n        []\n      )\n    )\n    return memo\n  }, [])\n}\n\n/**\n * Transform a key combination into an aria keyshortcuts string\n * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-keyshortcuts\n */\nexport const toAriaKeyshortcuts = (keys: string | string[]) => {\n  const parsed = parseKeys(keys)\n  return parsed\n    .map((keys) => {\n      return keys.join('+')\n    })\n    .join(' ')\n}\n\nconst keysMatch = (\n  pressedKeys: Set<string>,\n  targetKeys: Array<Set<string>>\n): boolean =>\n  targetKeys.some((b) => {\n    return (\n      pressedKeys.size === b.size &&\n      !Array.from(pressedKeys).some((v) => !b.has(v))\n    )\n  })\n\nconst getKeyFromEvent = (event: KeyboardEvent): string => {\n  const key = event.key.toLowerCase()\n\n  if (shiftedKeys[key]) {\n    return shiftedKeys[key]\n  }\n\n  return key\n}\n\nexport interface UseHotkeysOptions {\n  /**\n   * Whether to prevent the default behavior of the event.\n   * Eg. to override browser hotkeys.\n   * @default false\n   **/\n  preventDefault?: boolean\n  /**\n   * The element to attach the event listener to.\n   * @default window\n   */\n  targetElement?: HTMLElement | null\n  /**\n   * Ignore hotkeys when the target is an input element.\n   * @default ['INPUT', 'TEXTAREA', 'SELECT']\n   */\n  ignoreTags?: string[]\n  /**\n   * Whether to enable hotkeys when the target is a content editable element.\n   * @default false\n   */\n  enableOnContentEditable?: boolean\n}\n\n/**\n * useHotKeys React Hook\n *\n * Supports shifted keys like ?, =, >.\n *\n * ⌥ ⇧ ⌃ ⌘ shorthands are supported.\n *\n * @param keys The keys that trigger this hotkey\n * @param callback The function to execute when the keys are pressed\n * @param deps Deps for the callback function\n */\nexport const useHotkeys = (\n  keys: string | string[],\n  callback: (event: KeyboardEvent) => void,\n  options: UseHotkeysOptions | Array<any> = [],\n  deps?: Array<any>\n) => {\n  let _options: UseHotkeysOptions = {}\n  if (Array.isArray(options)) {\n    deps = options\n    _options = {}\n  } else {\n    _options = options\n    deps = deps || []\n  }\n\n  const {\n    ignoreTags = ['INPUT', 'TEXTAREA', 'SELECT'],\n    enableOnContentEditable,\n    preventDefault = false,\n  } = _options\n\n  const targetElement =\n    _options.targetElement || (typeof window === 'undefined' ? null : window)\n\n  const memoizedCallback = useCallback(callback, deps || [])\n\n  const targetKeys: Array<Set<string>> = useMemo(\n    () => parseKeys(keys).map((k) => new Set(k)),\n    []\n  )\n\n  const pressedKeys: Set<string> = useMemo(() => new Set(), [])\n  const bufferKeys: Set<string> = useMemo(() => new Set(), [])\n  const bufferTimeout = useRef<ReturnType<typeof setTimeout> | null>(null)\n\n  const isInputEvent = (event: KeyboardEvent) => {\n    const target = event.target as HTMLElement\n    return (\n      (target.isContentEditable && !enableOnContentEditable) ||\n      (ignoreTags.includes(target.tagName) &&\n        // @ts-ignore: This only exists on HTMLInputElements\n        !target.readOnly &&\n        // @ts-ignore: when targetElement is this input, we should trigger\n        target !== targetElement)\n    )\n  }\n\n  function onKeyDown(event: Event) {\n    if (isInputEvent(event as KeyboardEvent)) {\n      return\n    }\n\n    const key = getKeyFromEvent(event as KeyboardEvent)\n\n    pressedKeys.add(key)\n    bufferKeys.add(key)\n\n    if (bufferTimeout.current) {\n      clearTimeout(bufferTimeout.current)\n      bufferTimeout.current = null\n    }\n\n    bufferTimeout.current = setTimeout(() => {\n      bufferKeys.clear()\n    }, 400)\n\n    if (\n      keysMatch(pressedKeys, targetKeys) ||\n      (bufferKeys.size > 1 && keysMatch(bufferKeys, targetKeys))\n    ) {\n      if (preventDefault) {\n        event.preventDefault()\n      }\n      bufferKeys.clear() // make sure the buffer gets cleared\n      // execute on next tick to make sure the last keyup doesn't trigger in any focused field\n      setTimeout(() => memoizedCallback(event as KeyboardEvent), 0)\n    }\n  }\n\n  function onKeyUp(event: Event) {\n    // reset all keys on keyup\n    pressedKeys.clear()\n  }\n\n  function onWindowBlur() {\n    pressedKeys.clear()\n  }\n\n  useEffect(() => {\n    targetElement?.addEventListener('keydown', onKeyDown)\n    targetElement?.addEventListener('keyup', onKeyUp)\n    targetElement?.addEventListener('blur', onWindowBlur)\n\n    return () => {\n      targetElement?.removeEventListener('keydown', onKeyDown)\n      targetElement?.removeEventListener('keyup', onKeyUp)\n      targetElement?.removeEventListener('blur', onWindowBlur)\n    }\n  }, [memoizedCallback, targetElement])\n}\n","import { useHotkeysContext } from './provider'\nimport { useHotkeys, UseHotkeysOptions } from './use-hotkeys'\n\n/**\n * useHotkeysShortcut React Hook\n *\n * Accepts one key combination or a shortcut\n *\n * Shortcuts refer to a predefined hotkeys configuration.\n * @see https://www.saas-ui.dev/docs/navigation/hotkeys\n *\n * For example:\n * ctrl+f or general.search\n *\n * Supports shifted keys like ?, =, >.\n *\n * ⌥ ⇧ ⌃ ⌘ shorthands are supported.\n *\n * @param keyOrShortcut Key combinations or a hotkeys shortcut\n * @param callback The function to execute when the keys are pressed\n * @param deps Deps for the callback function\n * @returns The key combination(s)\n */\nexport const useHotkeysShortcut = (\n  keyOrShortcut: string | string[],\n  callback: (event: KeyboardEvent) => void,\n  options: UseHotkeysOptions | Array<any> = [],\n  deps?: Array<any>\n): string => {\n  const { hotkeys } = useHotkeysContext()\n\n  let keys = keyOrShortcut\n\n  if (typeof keys === 'string') {\n    const [group, key] = keys.split('.')\n\n    if (group && key) {\n      keys = hotkeys?.[group]?.hotkeys[key]?.command\n    }\n\n    if (!keys) {\n      keys = keyOrShortcut\n    }\n  }\n\n  useHotkeys(keys, callback, options, deps)\n\n  return typeof keys === 'string' ? keys : keys[0]\n}\n","import React from 'react'\nimport { UseHotkeysOptions, toAriaKeyshortcuts } from './use-hotkeys'\nimport { useHotkeysShortcut } from './use-hotkeys-shortcut'\n\nexport interface HotkeyProps {\n  /**\n   * The key combination.\n   * Supports shorthands: ⌥ ⇧ ⌃ ⌘\n   *\n   * Shifted keys like ? and + are handled automatically\n   */\n  command: string | string[]\n  /**\n   * Callback to be called when the key combination is pressed\n   */\n  callback: () => void\n  /**\n   * Options for the useHotkeys hook\n   */\n  hotkeyOptions?: UseHotkeysOptions\n  /**\n   * A single child or render prop function\n   */\n  children:\n    | string\n    | React.ReactElement\n    | ((props: {\n        keys: string | string[]\n        ariaKeyshortcuts?: string\n      }) => React.ReactNode)\n}\n\n/**\n * Registers a hotkey shortcut.\n * Supports shorthands: ⌥ ⇧ ⌃ ⌘\n * Shifted keys like ? and + are handled automatically\n *\n * Will pass `aria-keyshortcuts` to the child if it's a valid element, or render a span with the attribute\n */\nexport const Hotkey: React.FC<HotkeyProps> = (props) => {\n  const { command, callback, hotkeyOptions, children } = props\n\n  const keys = useHotkeysShortcut(command, callback, hotkeyOptions)\n\n  const ariaKeyshortcuts = React.useMemo(() => toAriaKeyshortcuts(keys), [keys])\n\n  if (typeof children === 'function') {\n    return children({ keys, ariaKeyshortcuts })\n  }\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement<any>(children, {\n      'aria-keyshortcuts': ariaKeyshortcuts,\n    })\n  }\n\n  return <span aria-keyshortcuts={ariaKeyshortcuts}>{children}</span>\n}\n","import React from 'react'\nimport {\n  HotkeysConfig,\n  HotkeysContextValues,\n  HotkeysProvider as HotkeysProviderBase,\n  useHotkeysContext as useHotkeysContextBase,\n} from './provider'\nimport { UseHotkeysOptions } from './use-hotkeys'\nimport { useHotkeysShortcut as useHotkeysShortcutBase } from './use-hotkeys-shortcut'\nimport { Hotkey as HotkeyBase, HotkeyProps } from './hotkey'\n\ntype ExtractHotkeys<T extends HotkeysConfig> = {\n  [Group in keyof T]: {\n    [Item in keyof T[Group]['hotkeys']]: `${string & Group}.${string & Item}`\n  }[keyof T[Group]['hotkeys']]\n}[keyof T]\n\nexport const createHotkeys = <Config extends HotkeysConfig>(\n  hotkeys: Config\n) => {\n  return {\n    hotkeys,\n    HotkeysProvider: (props: { children: React.ReactNode }) => (\n      <HotkeysProviderBase {...props} hotkeys={hotkeys} />\n    ),\n    useHotkeysContext: () =>\n      useHotkeysContextBase() as HotkeysContextValues<Config>,\n    useHotkeys: (\n      shortcut: ExtractHotkeys<Config>,\n      callback: (event: KeyboardEvent) => void,\n      options: UseHotkeysOptions | Array<any> = [],\n      deps?: Array<any>\n    ) => useHotkeysShortcutBase(shortcut, callback, options, deps),\n    Hotkey: HotkeyBase as React.FC<\n      Omit<HotkeyProps, 'command'> & {\n        command: ExtractHotkeys<Config>\n      }\n    >,\n  }\n}\n"],"mappings":"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","names":["React","keys","command","import_jsx_runtime","React","import_jsx_runtime"]}